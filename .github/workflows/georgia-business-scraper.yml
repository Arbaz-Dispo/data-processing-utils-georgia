name: Georgia Business Entity Processor

on:
  workflow_dispatch:  # Allows manual triggering
    inputs:
      control_number:
        description: 'Entity control number to process (e.g., "K805670")'
        required: true
        default: 'K805670'
      request_id:
        description: 'Unique request ID (for tracking requests)'
        required: false
        default: ''
      test_run:
        description: 'Test run (optional)'
        required: false
        default: 'false'
      force_rebuild:
        description: 'Force rebuild Docker image'
        required: false
        default: 'false'
        type: boolean
  push:
    paths:
      - 'Dockerfile'  # Rebuild image when Dockerfile changes
      - 'requirements.txt'  # Rebuild when dependencies change

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_RAW: ${{ github.repository }}/georgia-processor

jobs:
  # Build and push Docker image (only when needed)
  build-image:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.force_rebuild == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
    
    steps:
    - name: Set lowercase image name
      run: |
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME_RAW }}" | tr '[:upper:]' '[:lower:]')
        echo "IMAGE_NAME=$IMAGE_NAME_LOWER" >> $GITHUB_ENV
        echo "Using image name: $IMAGE_NAME_LOWER"
        
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx with aggressive caching
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:buildx-stable-1
          network=host
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build and push with maximum caching
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        cache-from: |
          type=gha
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache
        cache-to: |
          type=gha,mode=max
          type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache,mode=max
        platforms: linux/amd64
        build-args: |
          BUILDKIT_INLINE_CACHE=1

  # Run the Georgia business processing workflow
  process-georgia-entity:
    runs-on: ubuntu-latest
    needs: [build-image]
    if: always() && (needs.build-image.result == 'success' || needs.build-image.result == 'skipped')
    permissions:
      contents: read
      packages: read
    
    steps:
    - name: Set lowercase image name
      run: |
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME_RAW }}" | tr '[:upper:]' '[:lower:]')
        echo "IMAGE_NAME=$IMAGE_NAME_LOWER" >> $GITHUB_ENV
        echo "Using image name: $IMAGE_NAME_LOWER"
        
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Determine Docker image to use
      id: image
      run: |
        # Use the lowercase image name set at the job level
        IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Using Docker image: $IMAGE_TAG"
        
    - name: Optimized Docker setup (targeting 10-15 seconds)
      run: |
        IMAGE_TAG="${{ steps.image.outputs.image_tag }}"
        echo "üöÄ Optimized Docker setup: $IMAGE_TAG"
        
        # Enable Docker BuildKit for faster operations
        export DOCKER_BUILDKIT=1
        
        # Try multiple strategies for fastest pull
        echo "üì¶ Attempting pull strategies..."
        
        # Strategy 1: Direct pull (usually fastest if image exists)
        if timeout 45s docker pull "$IMAGE_TAG" 2>/dev/null; then
          echo "‚úÖ Pre-built image pulled successfully"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          
        # Strategy 2: Check if we can build with cache faster than pull
        elif [ -f "Dockerfile" ]; then
          echo "üî® Building with cache (may be faster than remote pull)..."
          docker build \
            --cache-from "$IMAGE_TAG" \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t georgia-processor:local \
            . || docker build -t georgia-processor:local .
          echo "IMAGE_TAG=georgia-processor:local" >> $GITHUB_ENV
          
        else
          echo "‚ùå No Dockerfile found and pull failed"
          exit 1
        fi
        
        echo "‚úÖ Docker setup complete!"
        
    - name: Parse control number and setup request ID
      id: parse-control
      run: |
        CONTROL_NUMBER="${{ github.event.inputs.control_number || 'K805670' }}"
        REQUEST_ID="${{ github.event.inputs.request_id || '' }}"
        
        # Generate a fallback request ID if none provided
        if [ -z "$REQUEST_ID" ]; then
          REQUEST_ID="ga-$(date +%Y%m%d)-${{ github.run_number }}-$(date +%s)"
        fi
        
        echo "control_number=$CONTROL_NUMBER" >> $GITHUB_OUTPUT
        echo "request_id=$REQUEST_ID" >> $GITHUB_OUTPUT
        echo "Processing Georgia entity control number: $CONTROL_NUMBER with request ID: $REQUEST_ID"
        
    - name: Run Georgia business processor
      id: processor
      env:
        CONTROL_NUMBER: ${{ steps.parse-control.outputs.control_number }}
        REQUEST_ID: ${{ steps.parse-control.outputs.request_id }}
      run: |
        echo "üöÄ Starting Georgia business processor..."
        echo "Control Number: $CONTROL_NUMBER"
        echo "Request ID: $REQUEST_ID"
        
        # Run the Georgia processor with timeout
        docker run --rm \
          --name georgia-processor-${{ github.run_number }} \
          -e CONTROL_NUMBER="${CONTROL_NUMBER}" \
          -e REQUEST_ID="${REQUEST_ID}" \
          -e PYTHONUNBUFFERED=1 \
          -v "$(pwd):/workspace" \
          -w /workspace \
          --memory="2g" \
          --cpus="1.5" \
          "$IMAGE_TAG" \
          timeout 900s python entity_processor.py "${CONTROL_NUMBER}"
        
        # Check if processing was successful
        if [ -f "processed_data_${REQUEST_ID}.json" ]; then
          echo "processing_success=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Processing completed successfully"
        else
          echo "processing_success=false" >> $GITHUB_OUTPUT
          echo "‚ùå Processing failed - no output file found"
        fi
        
    - name: List generated files
      run: |
        echo "Files in workspace:"
        ls -la
        echo "Looking for JSON files:"
        find . -name "*.json" -type f
        echo "Looking for log files:"
        find . -name "logs/*" -type f 2>/dev/null || echo "No logs directory found"
        echo "Looking for screenshots:"
        find . -name "logs/*.png" -type f 2>/dev/null || echo "No screenshots found"
        
    - name: Upload processed data as artifact
      uses: actions/upload-artifact@v4
      with:
        name: georgia-business-data-${{ steps.parse-control.outputs.request_id }}
        path: |
          processed_data_*.json
          logs/
        retention-days: 30
        if-no-files-found: warn
        
    - name: Show processing summary
      run: |
        echo "=== GEORGIA BUSINESS PROCESSING SUMMARY ==="
        echo "Control Number: ${{ steps.parse-control.outputs.control_number }}"
        echo "Request ID: ${{ steps.parse-control.outputs.request_id }}"
        echo "Processing Success: ${{ steps.processor.outputs.processing_success }}"
        
        if [ -f processed_data_*.json ]; then
          for file in processed_data_*.json; do
            if [ -f "$file" ]; then
              echo "üìÑ Processed data file: $file"
              echo "üìä File size: $(wc -c < "$file") bytes"
              
              # Try to extract summary from the JSON structure
              if command -v jq >/dev/null 2>&1; then
                echo "üìã Control Number: $(jq -r '.["Business Information"]["Control Number"] // "N/A"' "$file" 2>/dev/null)"
                echo "üè¢ Business Name: $(jq -r '.["Business Information"]["Business Name"] // "N/A"' "$file" 2>/dev/null)"
                echo "üìà Business Status: $(jq -r '.["Business Information"]["Business Status"] // "N/A"' "$file" 2>/dev/null)"
                echo "üìç Principal Office: $(jq -r '.["Business Information"]["Principal Office Address"] // "N/A"' "$file" 2>/dev/null)"
                
                # Count officers if present
                OFFICER_COUNT=$(jq '.["Officer Information"] | length // 0' "$file" 2>/dev/null || echo "0")
                echo "üë• Officers found: $OFFICER_COUNT"
              else
                echo "jq not available, showing file size only"
              fi
              echo "---"
            fi
          done
        else
          echo "‚ùå No processed data files found"
        fi 
